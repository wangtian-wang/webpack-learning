## 网络层面的优化
## 如何link外部资源优化
## 遇到script标签会触发渲染，以便获得最新的样式给JS代码????

```js
1: HTML解析器负责解析DOM，如果将style标签写在HTML里面，就会让HTML解析器进行解析style，增大解析DOM的时间，而且是异步解析的。
2: CSS解析器解析CSS, link到文档里面的样式表由CSS解析器解析。

```

## CSS阻塞
* css的加载会阻塞DOM的渲染
* css的加载不会阻塞DOM的解析

```js
1: 内联style标签中的样式
   1： 由HTML解析器解析
   2： 异步解析
   3： 不会阻塞浏览器的渲染（边解析，边渲染，可能会产生闪屏现象）
   4： 不阻塞DOM的解析
2： link外联样式表
   1： 由CSS解析器解析
   2： 阻塞浏览器的渲染。（解析执行完成，生成渲染树后，才渲染，可以解决闪屏现象）
   3： 不阻塞DOM的解析。（并行）
   3： 阻塞后面JS脚本的执行。（由于JS可能会操作DOM，不等CSS解析完成，JS可能会获得错误的信息。所以只好阻塞后面JS执行。
3：关于CSS阻塞的优化
	 核心理念：尽可能的提高外部CSS加载速度
				1： 使用CDN进行外部资源加速
        2： 对CSS文件压缩
        3： 减少HTTP请求次数
        4： 将多个CSS文件合并
        5： 优化样式表的代码
4： 关于阻塞
   1： CSS,JS的阻塞都不会阻塞浏览器加载外部资源（图片，视频，样式，脚本。。。） 浏览器的工作模式就是先将请求发送出去，至于资源到本地之后啥时候使用，由浏览器    			自己协调。这种做法效率高。
   2： CSS的解析和JS的执行是互斥的。
```



## css优化

```js
1: 使用willchange属性，将即将发生重排的DOM新开一个图层
2: 使用CSS3的能开启图层的属性
		1： transform等具有3D变换的CSS属性
		2： opacity代替visibility  前提是这个元素已经开启了图层，这样GPU在绘画的时候只是降低已有图形纹理的alpha值，来达到效果。
		3： position absolute
    4： z-index
		5：《canvas》
    6： will-change
		7：使用加速视频解码的video节点
    8: 脱离文档流
3: 将DOM离线后，再操作DOM。
	 对于display为none的元素来说，不在渲染树当中，对于这个元素的操作不会引发其他元素的重排。
4: 不要使用table布局
5: 将多次改变样式属性的操作合并成依次操作 比如添加一个class
6: 使用documentFragment
7: 使用requestAnimationFrame来开启动画
   API:
				requestAnimationFrame(fn) 执行这个api需要传入定义的动画进去，会产生一个代表当前动画的id
                cancleAnimationFrame(id)  取消id对应的动画
   优点:
				1: 系统来决定回调函数的执行时机；
        2： CPU节能： 当页面被隐藏或者最小化的时候，动画会停止执行；
        3： 函数节流： 回调函数在屏幕的每一次的刷新间隔只被执行一次。
        4： 会在每一帧中，将所有的DOM操作集中起来，在一次重回或者回流就完成，在隐藏或者不可见的元素中，将不会进行重绘。
        
   用法： 
   			let i = 0,id = requestAnimationFrame(move);
				function move () {
          i++；
          // 相关的动画操作
          id = requestAnimationFrame(move)
        }
       cancleAnimationFrame(id)
8: requestIdleCallback : 在浏览器的空闲时间内调用的函数，可以降不重要的任务延迟执行，防止页面卡顿。
	 requestIdleCallback（【callback】，【options -> timeout】）
   但是只有最新版本的浏览器才支持
9:   给图片在一开始就设置宽和高。
10： 利用img标签的loading： lazy 图片懒加载
11： 对于较大的图片可以采用渐进式图片。
12： 字体优化 
            @font-face{
              font-display: block  3s内不显示设置的字体图标，将使用默认的字体图标
            }

```



## html优化

```js
1:  语义化HTML： 
2： 提前申明字符编码，让浏览器确定如何渲染网页的内容
```



## js优化

```
1: 在进行获取DOM属性值操作的时候，先读后写，不要放在循环里面当成循环的变量
2: 虚拟滚动 viitual-scroll-list
3: 使用事件委托
4: 使用canvas，css3动画
5:
6:
7:
8:
9:
10:
```



## 存储优化

```js
强缓存的header参数
1： expire： HTTP1.0时代的规范； 值为绝对的GMT格式的时间字符串。用来表示当前服务器发送的资源的保质期。
2： cache-control 
		资源保质期的设定： max-age=number
		相对值，资源第一次的请求时间和max-age的有效时间计算出一个资源过期时间，用这个资源过期的时间和当前的请求时间进行比较，没过期就命中缓存
3： 浏览器存储的优化
	  storage事件
	  					监听一个页面的storage事件，当storage对象发生变化的时候 创建|更新|删除 被触发
	  					设置值的页面不会触发事件，与他共享的页面会触发事件
	  					参数：
	  							oldValue: 		如果调用clear（）值为null
                  newValue:			如果调用clear（）值为null
                  url			:     触发脚本变化的文档的URL
                  storageArea : 当前的storage对象
              日常使用：
              			多个页面之间的及时通信电商平台。当改变了一个页面的数据，另外一个页面能够及时响应。
4： 设置cookie
                            根据不同子域划分cookie，静态资源域名分配和动态资源不同的域名
                            不重要的请求中可以不携带cookie 控制cookie的大小
5： indexDB
						let request = window.indexDB.open('myDataBase');
						   request.onsuccess = function(e){
						   let db = e.target.result;
						   let ts = db.transaction(['student'], 'readwrite')
						   ts.objectStore('student').add({name:'happy'})
						   let r = ts.objectStore('student').get(5);
                 r.onsuccess = function(e){

                 }
						   }
	  				request.onupgradeneeded = function(e){
	  					let db = e.target.result;
	  					if(!db.objectStoreNames.contains('student')){
	  						let store = db.createObjectStore('student', {
	  							autoIncrement: 'value'
	  						})
	  					}
	  				}
	
```
## webwork
## 将占用时间长的JS代码块划分为小的代码块
## 动态导入组件
        异步组件 异步加载
## 优化polyfill

## 增加PWA技术
```
1： Web App Manifest  											 :    将网站添加到桌面，类似于原生native的体验
2：Service Worker    										   :	   离线缓存内容，配合cache api
3： Push Api & Notification Api             :    消息推送提醒
4： App Shell & App Skeleton								 :     App壳， 骨架屏
```

## CDN

```js
1: CDN的概念
   cdn是一组 分布在不同地理位置的web服务器，用于更加有效的向用户发布内容
2： 基础架构
	 简单的cdn网络由dns服务器和几台 缓存 服务器组成。
   工作过程：
   	1： 点击URL，本地DNS解析，解析权由CANME指向的CDN专用DNS服务器。
    2：CDN的DNS服务器将CDN的全局负载均衡设备IP地址发回给用户
    3： 用户向CDN的全局负载均衡设备发起内容URL访问请求。
    4： CDN全局负载均衡设备根据用户的IP地址，以及用户请求的内容的URL，选择一台设备，告诉用户向着台机器设备发起请求。
    5：区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务。
    6：全局负载均衡设备把服务器的IP地址返回给用户。
    7：用户向缓存服务器发起请求，缓存服务器响应用户的请求，将用户的所需要的内容传送到客户端
    

```

# 总结
        只在首屏的时候 加载当前需要的资源
        减小项目的资源体积
        优化时序   promise.all SSR prefetch ...
        合理利用缓存  cdn预热         cdn刷新 强制回源    和业务域名不一样

